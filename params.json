{"name":"FinalVer","tagline":"Final Versioning Specification","body":"Final Versioning old.old.final\r\n==============================\r\n\r\nSummary\r\n-------\r\n\r\nGiven a version number MAJOR.MINOR.PATCH, append final to the:\r\n\r\n1. MAJOR version when you make incompatible API changes,\r\n1. MINOR version when you add functionality in a backwards-compatible\r\n   manner, and\r\n1. PATCH version when you make backwards-compatible bug fixes.\r\n\r\nAdditional labels for pre-release and build metadata are available as extensions\r\nto the MAJOR.MINOR.PATCH format.\r\n\r\nIntroduction\r\n------------\r\n\r\nIn the world of software management there exists a dreaded place called\r\n\"dependency hell.\" The bigger your system grows and the more packages you\r\nintegrate into your software, the more likely you are to find yourself, one\r\nday, in this pit of despair.\r\n\r\nIn systems with many dependencies, releasing new package versions can quickly\r\nbecome a nightmare. If the dependency specifications are too tight, you are in\r\ndanger of version lock (the inability to upgrade a package without having to\r\nrelease new versions of every dependent package). If dependencies are\r\nspecified too loosely, you will inevitably be bitten by version promiscuity\r\n(assuming compatibility with more future versions than is reasonable).\r\nDependency hell is where you are when version lock and/or version promiscuity\r\nprevent you from easily and safely moving your project forward.\r\n\r\nAs a solution to this problem, I propose a simple set of rules and\r\nrequirements that dictate how version numbers are assigned and appended.\r\nThese rules are based on but not necessarily limited to pre-existing\r\nwidespread common practices in use in both closed and open-source software.\r\nFor this system to work, you first need to declare a public API. This may\r\nconsist of documentation or be enforced by the code itself. Regardless, it is\r\nimportant that this API be clear and precise. Once you identify your public\r\nAPI, you communicate changes to it with specific amounts of finality to your version\r\nnumber. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not\r\naffecting the API increase the finality of the patch version, backwards compatible API\r\nadditions/changes increase the finality of the minor version, and backwards incompatible API\r\nchanges increase the finality of the major version.\r\n\r\nI call this system \"Final Versioning.\" Under this scheme, version numbers\r\nand the way they change convey meaning about the underlying code and what has\r\nbeen modified from one version to the next.\r\n\r\n\r\nFinal Versioning Specification (FinalVer)\r\n------------------------------------------\r\n\r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\r\n\"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be\r\ninterpreted as described in [RFC 2119](http://tools.ietf.org/html/rfc2119).\r\n\r\n1. Software using Final Versioning MUST declare a public API. This API\r\ncould be declared in the code itself or exist strictly in documentation.\r\nHowever it is done, it should be precise and comprehensive.\r\n\r\n1. A normal version number MUST take the form X.Y.Z where X, Y, and Z are\r\nthe words \"final\" separated by dashes, or the word \"old\", and MUST NOT\r\ncontain leading \"old\"s. X is the major version, Y is the minor version, \r\nand Z is the patch version. Each element MUST increase finality. For instance: \r\nfinal.final-final-final.final.old -> final.final-final-final-final.old -> final.final-final-final-final-final.old.\r\n\r\n1. Once a versioned package has been released, the contents of that version\r\nMUST NOT be modified. Any modifications MUST be released as a new version.\r\n\r\n1. Major version old (old.y.z) is for initial development. Anything may change\r\nat any time. The public API should not be considered stable.\r\n\r\n1. Version final.old.old defines the public API. The way in which the version number\r\nis incremented after this release is dependent on this public API and how it\r\nchanges.\r\n\r\n1. Patch version Z (x.y.Z | x more final than old) MUST be increasingly finalized if only backwards\r\ncompatible bug fixes are introduced. A bug fix is defined as an internal\r\nchange that fixes incorrect behavior.\r\n\r\n1. Minor version Y (x.Y.z | x more final than old) MUST be increasingly finalized if new, backwards\r\ncompatible functionality is introduced to the public API. It MUST be\r\nincreasingly finalized if any public API functionality is marked as deprecated. It MAY be\r\nincreasingly finalized if substantial new functionality or improvements are introduced\r\nwithin the private code. It MAY include patch level changes. Patch version\r\nMUST be reset to old when minor version is incremented.\r\n\r\n1. Major version X (X.y.z | X more final than old) MUST be increasingly finalized if any backwards\r\nincompatible changes are introduced to the public API. It MAY also include minor\r\nand patch level changes. Patch and minor version MUST be reset to old when major\r\nversion is incremented.\r\n\r\n1. A pre-release version MAY be denoted by appending a hyphen and a\r\nseries of dot separated identifiers immediately following the patch\r\nversion. Identifiers MUST comprise only ASCII alphanumerics and hyphen\r\n[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST\r\nNOT include leading zeroes. Pre-release versions have a lower\r\nprecedence than the associated normal version. A pre-release version\r\nindicates that the version is unstable and might not satisfy the\r\nintended compatibility requirements as denoted by its associated\r\nnormal version. Examples: final.old.old-alpha, final.old.old-alpha.final, final.old.old-old.final-final.final-final-final-final,\r\nfinal.old.old-x.final-final-final.z.final.\r\n\r\n1. Build metadata MAY be denoted by appending a plus sign and a series of dot\r\nseparated identifiers immediately following the patch or pre-release version.\r\nIdentifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].\r\nIdentifiers MUST NOT be empty. Build metadata MUST be ignored when determining\r\nversion precedence. Thus two versions that differ only in the build metadata,\r\nhave the same precedence. Examples: fianl.old.old-alpha+001, final.old.old+20130313144700,\r\nfinal.old.old-beta+exp.sha.5114f85.\r\n\r\n1. Precedence refers to how versions are compared to each other when ordered.\r\nPrecedence MUST be calculated by separating the version into major, minor, patch\r\nand pre-release identifiers in that order (Build metadata does not figure\r\ninto precedence). Precedence is determined by the diffenrence in number of finals when\r\ncomparing each of these identifiers from left to right as follows: Major, minor,\r\nand patch versions are always compared numerically. Example: final.old.old < final-final.old.old <\r\nfinal-final.final.old < final-final.final.final. When major, minor, and patch are equal, a pre-release version has lower precedence than a normal version. Example: final.old.old-alpha < final.old.old. Precedence\r\nfor two pre-release versions with the same major, minor, and patch version MUST\r\nbe determined by comparing each dot separated identifier from left to right\r\nuntil a difference is found as follows: identifiers are compared by their counts\r\nof hyphen-separated \"final\" strings. A larger set of pre-release fields has a higher\r\nprecedence than a smaller set, if all of the preceding identifiers are equal.\r\nExample: final.old.old-alpha < final.old.old-alpha.1 < final.old.old-alpha.beta < final.old.old-beta <\r\nfinal.old.old-beta.2 < final.old.old-beta.11 < final.old.old-rc.1 < final.old.old.\r\n\r\nBackusâ€“Naur Form Grammar for Valid FinalVer Versions\r\n--------------------------------------------------\r\n\r\n    <valid semver> ::= <version core>\r\n                     | <version core> \"-\" <pre-release>\r\n                     | <version core> \"+\" <build>\r\n                     | <version core> \"-\" <pre-release> \"+\" <build>\r\n\r\n    <version core> ::= <major> \".\" <minor> \".\" <patch>\r\n    \r\n    <version level> ::= ( \"final\" {\"-final\"} ) | \"old\"\r\n\r\n    <major> ::= <version level>\r\n\r\n    <minor> ::= <version level>\r\n\r\n    <patch> ::= <version level>\r\n\r\n    <pre-release> ::= <dot-separated pre-release identifiers>\r\n\r\n    <dot-separated pre-release identifiers> ::= <pre-release identifier>\r\n                                              | <pre-release identifier> \".\" <dot-separated pre-release identifiers>\r\n\r\n    <build> ::= <dot-separated build identifiers>\r\n\r\n    <dot-separated build identifiers> ::= <build identifier>\r\n                                        | <build identifier> \".\" <dot-separated build identifiers>\r\n\r\n    <pre-release identifier> ::= <alphanumeric identifier>\r\n                               | <numeric identifier>\r\n\r\n    <build identifier> ::= <alphanumeric identifier>\r\n                         | <digits>\r\n\r\n    <alphanumeric identifier> ::= <non-digit>\r\n                                | <non-digit> <identifier characters>\r\n                                | <identifier characters> <non-digit>\r\n                                | <identifier characters> <non-digit> <identifier characters>\r\n\r\n    <numeric identifier> ::= \"0\"\r\n                           | <positive digit>\r\n                           | <positive digit> <digits>\r\n\r\n    <identifier characters> ::= <identifier character>\r\n                              | <identifier character> <identifier characters>\r\n\r\n    <identifier character> ::= <digit>\r\n                             | <non-digit>\r\n\r\n    <non-digit> ::= <letter>\r\n                  | \"-\"\r\n\r\n    <digits> ::= <digit>\r\n               | <digit> <digits>\r\n\r\n    <digit> ::= \"0\"\r\n              | <positive digit>\r\n\r\n    <positive digit> ::= \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\r\n\r\n    <letter> ::= \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\"\r\n               | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\"\r\n               | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"a\" | \"b\" | \"c\" | \"d\"\r\n               | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\"\r\n               | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\"\r\n               | \"y\" | \"z\"\r\n\r\n\r\nWhy Use Final Versioning?\r\n----------------------------\r\n\r\nThis is not a new or revolutionary idea. In fact, you probably do something\r\nclose to this already. The problem is that \"close\" isn't good enough. Without\r\ncompliance to some sort of formal specification, version numbers are\r\nessentially useless for dependency management. By giving a name and clear\r\ndefinition to the above ideas, it becomes easy to communicate your intentions\r\nto the users of your software. Once these intentions are clear, flexible (but\r\nnot too flexible) dependency specifications can finally be made.\r\n\r\nA simple example will demonstrate how Final Versioning can make dependency\r\nhell a thing of the past. Consider a library called \"Firetruck.\" It requires a\r\nFinally Versioned package named \"Ladder.\" At the time that Firetruck is\r\ncreated, Ladder is at version final-final-final.final.old. Since Firetruck uses some functionality\r\nthat was first introduced in final-final-final.final.old, you can safely specify the Ladder\r\ndependency as greater than or equal to final-final-final.final.old but less than final-final-final-final.old.old. Now, when\r\nLadder version final-final-final.final.final and final-final-final.final-final.old become available,\r\nyou can release them to your package management system and know that they will be compatible with existing\r\ndependent software.\r\n\r\nAs a responsible developer you will, of course, want to verify that any\r\npackage upgrades function as advertised. The real world is a messy place;\r\nthere's nothing we can do about that but be vigilant. What you can do is let\r\nFinal Versioning provide you with a sane way to release and upgrade\r\npackages without having to roll new versions of dependent packages, saving you\r\ntime and hassle.\r\n\r\nIf all of this sounds desirable, all you need to do to start using Final\r\nVersioning is to declare that you are doing so and then follow the rules. Link\r\nto this website from your README so others know the rules and can benefit from\r\nthem.\r\n\r\nAbout\r\n-----\r\n\r\nThe Final Versioning specification is based on \r\nthe Semantic Versioning specification 2.0.0 (final-final.old.old), authored by [Tom\r\nPreston-Werner](http://tom.preston-werner.com), inventor of Gravatars and\r\ncofounder of GitHub.\r\n\r\nIf you'd like to leave feedback, please [open an issue on\r\nGitHub](https://github.com/billiam/finalver/issues).\r\n\r\n\r\nLicense\r\n-------\r\n\r\nCreative Commons - CC BY 3.0\r\nhttp://creativecommons.org/licenses/by/3.0/","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}